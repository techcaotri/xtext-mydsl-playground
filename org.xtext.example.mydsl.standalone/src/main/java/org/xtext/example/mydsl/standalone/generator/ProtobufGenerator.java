package org.xtext.example.mydsl.standalone.generator;

import com.google.protobuf.DescriptorProtos;
import com.google.protobuf.DescriptorProtos.*;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
// Import specific classes to avoid ambiguity with java.lang.Enum
import org.xtext.example.mydsl.myDsl.Model;
import org.xtext.example.mydsl.myDsl.Entity;
import org.xtext.example.mydsl.myDsl.Attribute;
import org.xtext.example.mydsl.myDsl.StaticMember;
import org.xtext.example.mydsl.myDsl.EnumValue;
import org.xtext.example.mydsl.myDsl.Type;
import org.xtext.example.mydsl.myDsl.PrimitiveType;
import org.xtext.example.mydsl.myDsl.PrimitiveTypeName;
import org.xtext.example.mydsl.myDsl.CustomType;
import org.xtext.example.mydsl.myDsl.ArrayType;
import org.xtext.example.mydsl.myDsl.TemplateType;

import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Generator for Protobuf .proto files and descriptor sets from MyDsl models
 * Note: Methods from entities are intentionally ignored in protobuf generation
 * 
 * @author MyDsl Standalone Generator
 */
public class ProtobufGenerator {
    private static final Logger logger = LogManager.getLogger(ProtobufGenerator.class);
    
    private static final Map<PrimitiveTypeName, FieldDescriptorProto.Type> TYPE_MAPPING = Map.ofEntries(
        Map.entry(PrimitiveTypeName.BOOL, FieldDescriptorProto.Type.TYPE_BOOL),
        Map.entry(PrimitiveTypeName.INT, FieldDescriptorProto.Type.TYPE_INT32),
        Map.entry(PrimitiveTypeName.LONG, FieldDescriptorProto.Type.TYPE_INT64),
        Map.entry(PrimitiveTypeName.LONGLONG, FieldDescriptorProto.Type.TYPE_INT64),
        Map.entry(PrimitiveTypeName.FLOAT, FieldDescriptorProto.Type.TYPE_FLOAT),
        Map.entry(PrimitiveTypeName.DOUBLE, FieldDescriptorProto.Type.TYPE_DOUBLE),
        Map.entry(PrimitiveTypeName.STRING, FieldDescriptorProto.Type.TYPE_STRING),
        Map.entry(PrimitiveTypeName.CHAR, FieldDescriptorProto.Type.TYPE_INT32),
        Map.entry(PrimitiveTypeName.SIZE_T, FieldDescriptorProto.Type.TYPE_UINT64)
    );
    
    private Map<String, Integer> fieldNumberCounter;
    private Set<String> imports;
    
    public void generate(Model model, Path outputPath, boolean generateBinary) throws IOException {
        fieldNumberCounter = new HashMap<>();
        imports = new HashSet<>();
        
        // Generate .proto file
        String protoFileName = model.getName().toLowerCase() + ".proto";
        Path protoFile = outputPath.resolve(protoFileName);
        String protoContent = generateProtoFile(model);
        Files.writeString(protoFile, protoContent, StandardCharsets.UTF_8);
        logger.info("Generated proto file: {}", protoFile);
        
        // Generate descriptor set if requested
        if (generateBinary) {
            String descFileName = model.getName().toLowerCase() + ".desc";
            Path descFile = outputPath.resolve(descFileName);
            generateDescriptorSet(model, descFile);
            logger.info("Generated descriptor set: {}", descFile);
        }
    }
    
    private String generateProtoFile(Model model) {
        StringBuilder proto = new StringBuilder();
        
        // Header
        proto.append("// Generated by MyDsl Standalone Generator\n");
        proto.append("// Source: ").append(model.getName()).append("\n");
        proto.append("// Note: Methods are intentionally ignored for protobuf generation\n\n");
        
        proto.append("syntax = \"proto3\";\n\n");
        
        // Package declaration
        String packageName = determinePackage(model);
        if (!packageName.isEmpty()) {
            proto.append("package ").append(packageName).append(";\n\n");
        }
        
        // Options
        proto.append("option java_package = \"").append(packageName.isEmpty() ? "com.generated" : packageName).append("\";\n");
        proto.append("option java_outer_classname = \"").append(model.getName()).append("Proto\";\n");
        proto.append("option java_multiple_files = true;\n");
        proto.append("option optimize_for = SPEED;\n\n");
        
        // Imports
        if (!imports.isEmpty()) {
            for (String imp : imports) {
                proto.append("import \"").append(imp).append("\";\n");
            }
            proto.append("\n");
        }
        
        // Generate enums
        for (org.xtext.example.mydsl.myDsl.Enum enumDef : model.getEnums()) {
            proto.append(generateEnum(enumDef));
            proto.append("\n");
        }
        
        // Generate messages for entities
        for (Entity entity : model.getEntities()) {
            proto.append(generateMessage(entity));
            proto.append("\n");
        }
        
        // No service generation - methods are completely ignored
        
        return proto.toString();
    }
    
    private String generateEnum(org.xtext.example.mydsl.myDsl.Enum enumDef) {
        StringBuilder sb = new StringBuilder();
        
        sb.append("// Enum: ").append(enumDef.getName()).append("\n");
        sb.append("enum ").append(enumDef.getName()).append(" {\n");
        
        // Protobuf requires first enum value to be 0
        boolean hasZero = enumDef.getValues().stream().anyMatch(v -> v.getValue() == 0);
        if (!hasZero) {
            sb.append("  ").append(enumDef.getName().toUpperCase()).append("_UNSPECIFIED = 0;\n");
        }
        
        for (EnumValue value : enumDef.getValues()) {
            sb.append("  ").append(value.getName());
            if (value.getValue() != 0) {
                sb.append(" = ").append(value.getValue());
            }
            sb.append(";\n");
        }
        
        sb.append("}\n");
        return sb.toString();
    }
    
    private String generateMessage(Entity entity) {
        StringBuilder sb = new StringBuilder();
        
        // Add comment
        if (entity.getDescription() != null && !entity.getDescription().isEmpty()) {
            sb.append("// ").append(entity.getDescription()).append("\n");
        } else {
            sb.append("// Message for entity: ").append(entity.getName()).append("\n");
        }
        
        // Note: Methods are intentionally ignored for protobuf generation
        
        sb.append("message ").append(entity.getName()).append(" {\n");
        
        int fieldNumber = 1;
        fieldNumberCounter.put(entity.getName(), fieldNumber);
        
        // Handle inheritance
        if (entity.getSuperType() != null) {
            sb.append("  // Inherited from ").append(entity.getSuperType().getName()).append("\n");
            sb.append("  ").append(entity.getSuperType().getName()).append(" base = ").append(fieldNumber++).append(";\n");
        }
        
        // Generate fields for attributes
        for (Attribute attr : entity.getAttributes()) {
            String fieldDef = generateField(attr, fieldNumber++);
            if (fieldDef != null) {
                sb.append("  ").append(fieldDef).append("\n");
            }
        }
        
        // Generate fields for static members
        for (StaticMember member : entity.getStaticMembers()) {
            String fieldDef = generateStaticField(member, fieldNumber++);
            if (fieldDef != null) {
                sb.append("  ").append(fieldDef).append("\n");
            }
        }
        
        // Add nested messages for inner classes
        for (Entity inner : entity.getInnerClasses()) {
            String innerMessage = generateMessage(inner);
            // Indent nested message
            String indented = Arrays.stream(innerMessage.split("\n"))
                .map(line -> "  " + line)
                .collect(Collectors.joining("\n"));
            sb.append("\n").append(indented).append("\n");
        }
        
        // Store final field number
        fieldNumberCounter.put(entity.getName(), fieldNumber - 1);
        
        sb.append("}\n");
        return sb.toString();
    }
    
    private String generateField(Attribute attr, int fieldNumber) {
        String fieldType = mapTypeToProto(attr.getType());
        if (fieldType == null) {
            logger.warn("Skipping attribute {} - unsupported type", attr.getName());
            return null;
        }
        
        StringBuilder sb = new StringBuilder();
        
        // Add comment if description exists
        if (attr.getDescription() != null && !attr.getDescription().isEmpty()) {
            sb.append("// ").append(attr.getDescription()).append("\n  ");
        }
        
        // Handle repeated fields (arrays/lists)
        if (attr.getType() instanceof ArrayType || isListType(attr.getType())) {
            sb.append("repeated ");
        }
        
        sb.append(fieldType).append(" ").append(toSnakeCase(attr.getName()));
        sb.append(" = ").append(fieldNumber).append(";");
        
        return sb.toString();
    }
    
    private String generateStaticField(StaticMember member, int fieldNumber) {
        String fieldType = mapTypeToProto(member.getType());
        if (fieldType == null) {
            return null;
        }
        
        return "// static field\n  " + fieldType + " " + toSnakeCase(member.getName()) + " = " + fieldNumber + ";";
    }
    
    private String mapTypeToProto(Type type) {
        if (type instanceof PrimitiveType) {
            PrimitiveType pt = (PrimitiveType) type;
            switch (pt.getName()) {
                case BOOL: return "bool";
                case INT: return "int32";
                case LONG: return "int64";
                case LONGLONG: return "int64";
                case FLOAT: return "float";
                case DOUBLE: return "double";
                case STRING: return "string";
                case CHAR: return "int32";
                case SIZE_T: return "uint64";
                case VOID: return null;
                default: return "bytes";
            }
        } else if (type instanceof CustomType) {
            CustomType ct = (CustomType) type;
            return ct.getName().getName();
        } else if (type instanceof ArrayType) {
            ArrayType at = (ArrayType) type;
            return mapTypeToProto(at.getElementType());
        } else if (type instanceof TemplateType) {
            TemplateType tt = (TemplateType) type;
            // Handle common template types
            if ("vector".equals(tt.getName()) || "list".equals(tt.getName())) {
                if (!tt.getTemplateArgs().isEmpty()) {
                    return mapTypeToProto(tt.getTemplateArgs().get(0));
                }
            } else if ("map".equals(tt.getName()) && tt.getTemplateArgs().size() == 2) {
                // Protobuf map syntax
                String keyType = mapTypeToProto(tt.getTemplateArgs().get(0));
                String valueType = mapTypeToProto(tt.getTemplateArgs().get(1));
                return "map<" + keyType + ", " + valueType + ">";
            }
        }
        
        return "bytes"; // Default fallback
    }
    
    private boolean isListType(Type type) {
        if (type instanceof TemplateType) {
            TemplateType tt = (TemplateType) type;
            return "vector".equals(tt.getName()) || "list".equals(tt.getName()) || 
                   "set".equals(tt.getName()) || "deque".equals(tt.getName());
        }
        return false;
    }
    
    private void generateDescriptorSet(Model model, Path outputFile) throws IOException {
        FileDescriptorSet.Builder setBuilder = FileDescriptorSet.newBuilder();
        FileDescriptorProto.Builder fileBuilder = FileDescriptorProto.newBuilder();
        
        // Set file properties
        fileBuilder.setName(model.getName().toLowerCase() + ".proto");
        fileBuilder.setSyntax("proto3");
        
        String packageName = determinePackage(model);
        if (!packageName.isEmpty()) {
            fileBuilder.setPackage(packageName);
        }
        
        // Set options
        FileOptions.Builder optionsBuilder = FileOptions.newBuilder();
        optionsBuilder.setJavaPackage(packageName.isEmpty() ? "com.generated" : packageName);
        optionsBuilder.setJavaOuterClassname(model.getName() + "Proto");
        optionsBuilder.setJavaMultipleFiles(true);
        optionsBuilder.setOptimizeFor(FileOptions.OptimizeMode.SPEED);
        fileBuilder.setOptions(optionsBuilder);
        
        // Add enums
        for (org.xtext.example.mydsl.myDsl.Enum enumDef : model.getEnums()) {
            fileBuilder.addEnumType(buildEnumDescriptor(enumDef));
        }
        
        // Add messages
        for (Entity entity : model.getEntities()) {
            fileBuilder.addMessageType(buildMessageDescriptor(entity));
        }
        
        // No services - methods are completely ignored
        
        setBuilder.addFile(fileBuilder);
        
        // Write binary descriptor set
        try (FileOutputStream fos = new FileOutputStream(outputFile.toFile())) {
            setBuilder.build().writeTo(fos);
        }
    }
    
    private EnumDescriptorProto buildEnumDescriptor(org.xtext.example.mydsl.myDsl.Enum enumDef) {
        EnumDescriptorProto.Builder builder = EnumDescriptorProto.newBuilder();
        builder.setName(enumDef.getName());
        
        // Add unspecified value if needed
        boolean hasZero = enumDef.getValues().stream().anyMatch(v -> v.getValue() == 0);
        if (!hasZero) {
            builder.addValue(EnumValueDescriptorProto.newBuilder()
                .setName(enumDef.getName().toUpperCase() + "_UNSPECIFIED")
                .setNumber(0));
        }
        
        for (EnumValue value : enumDef.getValues()) {
            builder.addValue(EnumValueDescriptorProto.newBuilder()
                .setName(value.getName())
                .setNumber(value.getValue()));
        }
        
        return builder.build();
    }
    
    private DescriptorProto buildMessageDescriptor(Entity entity) {
        DescriptorProto.Builder builder = DescriptorProto.newBuilder();
        builder.setName(entity.getName());
        
        int fieldNumber = 1;
        
        // Handle inheritance
        if (entity.getSuperType() != null) {
            builder.addField(FieldDescriptorProto.newBuilder()
                .setName("base")
                .setNumber(fieldNumber++)
                .setType(FieldDescriptorProto.Type.TYPE_MESSAGE)
                .setTypeName(entity.getSuperType().getName())
                .setLabel(FieldDescriptorProto.Label.LABEL_OPTIONAL));
        }
        
        // Add fields for attributes only - methods are ignored
        for (Attribute attr : entity.getAttributes()) {
            FieldDescriptorProto field = buildFieldDescriptor(attr, fieldNumber++);
            if (field != null) {
                builder.addField(field);
            }
        }
        
        // Add nested messages for inner classes
        for (Entity inner : entity.getInnerClasses()) {
            builder.addNestedType(buildMessageDescriptor(inner));
        }
        
        return builder.build();
    }
    
    private FieldDescriptorProto buildFieldDescriptor(Attribute attr, int fieldNumber) {
        FieldDescriptorProto.Builder builder = FieldDescriptorProto.newBuilder();
        builder.setName(toSnakeCase(attr.getName()));
        builder.setNumber(fieldNumber);
        
        // Determine type and label
        Type attrType = attr.getType();
        if (attrType instanceof ArrayType || isListType(attrType)) {
            builder.setLabel(FieldDescriptorProto.Label.LABEL_REPEATED);
            if (attrType instanceof ArrayType) {
                attrType = ((ArrayType) attrType).getElementType();
            }
        } else {
            builder.setLabel(FieldDescriptorProto.Label.LABEL_OPTIONAL);
        }
        
        // Set type
        if (attrType instanceof PrimitiveType) {
            PrimitiveType pt = (PrimitiveType) attrType;
            FieldDescriptorProto.Type protoType = TYPE_MAPPING.get(pt.getName());
            if (protoType != null) {
                builder.setType(protoType);
            } else {
                builder.setType(FieldDescriptorProto.Type.TYPE_BYTES);
            }
        } else if (attrType instanceof CustomType) {
            builder.setType(FieldDescriptorProto.Type.TYPE_MESSAGE);
            builder.setTypeName(((CustomType) attrType).getName().getName());
        } else {
            builder.setType(FieldDescriptorProto.Type.TYPE_BYTES);
        }
        
        return builder.build();
    }
    
    private String determinePackage(Model model) {
        // Try to find a common namespace from entities
        Set<String> namespaces = model.getEntities().stream()
            .map(Entity::getNamespace)
            .filter(Objects::nonNull)
            .filter(ns -> !ns.isEmpty())
            .collect(Collectors.toSet());
            
        if (namespaces.size() == 1) {
            return namespaces.iterator().next().replace("::", ".").replaceAll("^\"|\"$", "");
        }
        
        // Default package based on model name
        return "com.generated." + model.getName().toLowerCase();
    }
    
    private String toSnakeCase(String camelCase) {
        return camelCase.replaceAll("([a-z])([A-Z])", "$1_$2").toLowerCase();
    }
    
    private String capitalize(String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }
        return str.substring(0, 1).toUpperCase() + str.substring(1);
    }
}
